# [Jon Gjengset](https://www.youtube.com/watch?v=o2ob8zkeq2s)

> So a waker gets passed all the way down to the resource. And the idea is when a `Future` returns pending, so the whole _task_ becomes `Pending`, it's moved to the sort of non-runnable queue. And when the `Waker` that was passed into that `Future`, when it returns `Pending`, when someone calls `wake` on it, that means this `Future` might be able to make progress again. And so this is a signal to `tokio` that this `Future` should be moved from the non-runnable queue into the runnable queue and then get picked up by a worker pool thread again. And so you might wonder, well, **who calls `wake`**? And this is where, when we looked at `tokio::runtime`, you'll see up here that `runtime` has this **I\O event loop**. And this is **separate from the scheduler**. The I\O event loop and the scheduler, _they don't run on different threads necessarily_, but they're sort of _distinct components_ or services that are provided by the runtime. The scheduler chooses what to pick up next. And the I\O event loop is _looking for these events_ that might mean that some task can make progress and then _calling `wake` on the appropriate `Waker`_. If we take an example of something that ultimately reads from a TCP stream, the `Context`, the `poll` method gets called by the `tokio` runtime scheduler. It passes in the `Context` that **represents the current task**. It's passed all the way down to the `AsyncRead::poll_read` call on the TCP stream. That tries to read from the socket and gets told there's no more data. What it will do is then internally in `tokio`, internally in the TCP stream type, it'll take the `Waker` in the `Context` that was given into `AsyncRead::poll_read`, so the `Waker` that was inside here, and it will _save that `Waker` inside of a little secret storage area_ next to the TCP stream's file descriptor. And all of that is _stored inside of the I\O event loop inside `tokio`_. And the I\O event loop, whenever a worker runs out of stuff to do, or in reality, every now and again, this event loop is going to be _looking for events on all of these little secret compartment file descriptors_. So look for, has anything happened on any resource that I know about and have a `Waker` for? And if so, I will go to that thing and call `Waker::wake` on it, which ultimately then kicks off all this machinery of _moving things into the runnable queue_.

> And then you just need to guarantee somehow that if you ever return `Poll::Pending` instead of `Poll::Ready` here, then you have some way to guarantee that the `Waker` inside of this context will eventually be called `wake` on, when you might be able to make progress. That's the contract you have to fulfill for your own resources.

> Rather than figure out how to do `Future::poll` calls and distributing this `Waker` and stuff, you can often get away with just using a `tokio::sync::Notify`. And so in your resource, what you actually do is you just construct a `tokio::util::Notify` and you do give a clone of the `Notify` away to something or stick it in a queue somewhere that is going to call `notify_one` when there's more work to do. And then in the resource, wherever you are in your asynchronous function, you then just call `Notify::notified().await`. And that way, the only thing that you need to be concerned about is making sure you call `notify_one` from somewhere and you don't ever need to touch the sort of low level `Future::poll` interface. So that's where `tokio::sync::Notify` can be really useful. It's useful in other places too, but that's the main place I've found it to be useful.

> Q: Does spawning a `tokio` task allocate a new stack like Go or Beam instead of using memory as needed?
> A: Yes, you can think of that as roughly right... But when you spawn a task, it does get its own heap allocation for the task and for the state machine.

> So the way that you can implement **cancellation safety** internally in some kind of resource is just by having it do _atomic_ things. I don't necessarily mean CPU atomics, although that can be the way to do it. So that... You _basically don't have any `.await` points between when you **consume** a value or like consume a resource like reading bytes from a file socket and when you **return** them_.
> ...Because at any `.await` point you could been dropped.

> It's funny how cancellation on safe code is still safe rust.
> So safe Rust is a very particular meaning, right? Safe rust means that it cannot have _memory unsafety_. Things like one type being treated as another or have undefined behavior. There's no undefined behavior here. You just dropped a bunch of data, right? So it's wrong, but it's not memory unsafety. And that's what we mean by safe in Rust. So this is more of a definitional question of what does safe mean. And when we say that something is unsafe, do we mean the formal sense of Rust unsafety? Or do we mean unsafe as in general, like this could lead to buggy behavior? And those are two different meanings of the word.

> `reqwest` says it wants a `tokio` 1.x runtime when running with another runtime. Is `tokio` doing something special that `reqwest` needs? Well, soâ€¦ This gets at the fact that in order for `tokio` to know when `Future` need to move from the non-runnable queue to the runnable queue, it needs to know which things those `Future` are waiting for. Which means that when those `Future` use, for example, a `tokio` TCP stream, _that's how `tokio` knows_. **It's because `tokio` implemented the TCP stream, so it knows what to wait for**. So it knows when to move them and _basically how to implement `Waker::wake`_. If you try to use a non-`tokio` runtime, but you're trying to use the `tokio` resources, you run into a problem because the `tokio` resources, like a TCP stream, when you call `Future::poll` on it and it realizes, like, let's say you call `poll_read` on a TCP stream, it knows that, oh, I didn't have any bytes to read. I need to register myself somewhere so that the runtime... So that I can notify the runtime when I need to resume, basically I need to _register myself with the I/O event loop_. So it looks for an I/O event loop, _specifically the `tokio` I/O event loop_, and it doesn't find one. Then it doesn't know where to put its `Waker` and its file descriptor for something to be picked up later. And so that's why _when you use the `tokio` I/O resources, **you need to also use the `tokio` runtime**_ because the I/O resources are tied to the I/O event loop. If you use, let's say, the `async_std` runtime or something, but you're trying to use a `tokio` resource, then when a `poll_read` happens, it doesn't have anywhere to put its state that it can rely on will call `Waker::wake` later. And so `reqwest`, I believe, uses `tokio` resources all the way down. Like it uses `tokio` TCP streams, for example. And you can't run that in a non-`tokio` runtime because that connection with the I/O event loop would be lost.
